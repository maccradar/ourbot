#include "USBInterface-component.hpp"
#include <rtt/Component.hpp>
#include <iostream>
#include <fcntl.h>
#include <termios.h>
#include <sys/ioctl.h>

USBInterface::USBInterface(std::string const& name) :
	SerialInterface(name), _usb_port_name(std::string("/dev/ttyACM0"))
{
	addProperty("_usb_port_name",_usb_port_name).doc("The usb port name.");

	addOperation("setUSBPortName", &USBInterface::setUSBPortName, this).doc("Set the _usb_port_name property.");
	addOperation("isConnectedSerial", &USBInterface::isConnectedSerial, this).doc("Returns true if the serial connection is ok.");
	addOperation("available", &USBInterface::available, this).doc("Returns the amount of available characters in the buffer.");
}

bool USBInterface::configureHook()
{

#ifndef USBINTERFACE_TESTFLAG 
	//do nothing
#else
	setUSBPortName("/dev/ttyACM0");
	connectSerial();
	
	return setPeriod(0.01);
#endif //STANDALONE
}

void USBInterface::updateHook()
{
#ifndef USBINTERFACE_TESTFLAG
	//do nothing
#else
	uint8_t bytes[100];
	int numbytes = readBytes(bytes, 100);
	if(numbytes > 0){
		std::cout << std::string((char*)bytes,numbytes);
	}
#endif //STANDALONE
}

void USBInterface::setUSBPortName(std::string usb_port_name)
{
	_usb_port_name = usb_port_name;
}

bool USBInterface::connectSerial()
{
	struct termios newtio;
	bzero(&newtio, sizeof(newtio));
	
	newtio.c_iflag = IGNPAR | ICRNL;
  newtio.c_oflag = 0;
  newtio.c_cflag = B115200 | CRTSCTS | CS8 | CLOCAL | CREAD;
  newtio.c_lflag = ICANON;
	
	connectSerial(newtio);
}

bool USBInterface::connectSerial(struct termios newtio)
{
	/* 
	Open modem device for reading and writing and not as controlling tty
	because we don't want to get killed if linenoise sends CTRL-C.
	*/
  /*int usb_fd = open(_usb_port_name.c_str(), O_RDWR | O_NOCTTY | O_NDELAY);
  if (usb_fd > 0) {
    //now clean the modem line and activate the settings for the port
    tcflush(usb_fd,TCIFLUSH);
    fcntl(usb_fd, F_SETFL, FNDELAY); //for lidar
    tcsetattr(usb_fd,TCSANOW,&newtio);
    uint32_t controll = TIOCM_DTR;			//for lidar
    ioctl(usb_fd, TIOCMBIC, &controll);	//for lidar
    
    close(usb_fd);
     
    _usb_stream.open(_usb_port_name.c_str(), std::fstream::in | std::fstream::out);
    
    return true;
  } else {
  	RTT::log(RTT::Fatal) << "USB port " << _usb_port_name.c_str() << ": unable to open correctly." << RTT::endlog();
  	return false;
  }*/
  
  _usb_fd = open(_usb_port_name.c_str(), O_RDWR | O_NOCTTY | O_NDELAY);

  if (_usb_fd == -1) return false;

  struct termios options, oldopt;
  tcgetattr(_usb_fd, &oldopt);
  bzero(&options,sizeof(struct termios));

  cfsetispeed(&options, B115200);
  cfsetospeed(&options, B115200);
  
  // enable rx and tx
  options.c_cflag |= (CLOCAL | CREAD);

  options.c_cflag &= ~PARENB; //no checkbit
  options.c_cflag &= ~CSTOPB; //1bit stop bit

  options.c_cflag &= ~CSIZE;
  options.c_cflag |= CS8; /* Select 8 data bits */

#ifdef CNEW_RTSCTS
  options.c_cflag &= ~CNEW_RTSCTS; // no hw flow control
#endif

  options.c_iflag &= ~(IXON | IXOFF | IXANY); // no sw flow control

  // raw input mode   
  options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
  // raw output mode   
  options.c_oflag &= ~OPOST;
  
  tcflush(_usb_fd,TCIFLUSH); 

  if (fcntl(_usb_fd, F_SETFL, FNDELAY))
  {
      disconnectSerial();
      return false;
  }
  if (tcsetattr(_usb_fd, TCSANOW, &options))
  {
      disconnectSerial();
      return false;
  }

  //Clear the DTR bit to let the motor spin
  uint32_t controll = TIOCM_DTR;
  ioctl(_usb_fd, TIOCMBIC, &controll);
  
  return true;
}

bool USBInterface::disconnectSerial()
{
	_usb_stream.close();
	return !_usb_stream.is_open();
}

bool USBInterface::isConnectedSerial()
{
	return _usb_stream.is_open();
}

int USBInterface::available()
{
	// TODO: make this work correctly
	_usb_stream.seekg(0, _usb_stream.end);
	int bytes_available = _usb_stream.tellg();
	_usb_stream.seekg(0, _usb_stream.beg);
	
	return bytes_available;
}

int USBInterface::readByte(uint8_t* byte)
{
	return readBytes(byte, 1);	
}

int USBInterface::readBytes(uint8_t* bytes, uint32_t length)
{
	/*if(_usb_stream.eof()){
		_usb_stream.clear();
	} else if(_usb_stream.fail()) {
		RTT::log(RTT::Warning) << "USB port " << _usb_port_name.c_str() << " fail bit set." << RTT::endlog();
	}

	_usb_stream.readsome((char*)bytes,length);	
	return _usb_stream.gcount();*/
	
	int ans = read(_usb_fd, bytes, length);
  
  if (ans == -1) ans=0;
  return ans;
}

int USBInterface::writeByte(uint8_t byte)
{
	return writeBytes(&byte, 1);
}

int USBInterface::writeBytes(uint8_t* bytes, uint32_t length)
{
	/*_usb_stream.write((char*)bytes, length);
	return length;*/
	
	if (bytes == NULL || length == 0) return 0;
    
  uint32_t tx_len = 0;
  do {
      int ans = write(_usb_fd, bytes + tx_len, length-tx_len);
      
      if (ans == -1) return tx_len;
      
      tx_len += ans;
  }while (tx_len<length);

  return tx_len;
}

#ifdef USBINTERFACE_TESTFLAG
ORO_CREATE_COMPONENT(USBInterface);
#endif //USBINTERFACE_TESTFLAG
