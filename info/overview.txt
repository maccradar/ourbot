OURBOT
---------------------------------------------------------------------

Components
----------

- ControllerInterface: needs to be inherited. Provides following methods for its children:
      virtual bool controlUpdate() = 0;
      virtual bool initialize() = 0;
      double getControlSampleRate();
      std::vector<double> getRefPose();
      std::vector<double> getRefFfw();
      std::vector<double> getEstPose();
      std::vector<double> getCmdVelocity();
      void setCmdVelocity(std::vector<double> const&);

- EstimatorInterface: needs to be inherited. Provides following methods for its children:
      virtual bool estimateUpdate() = 0;
      virtual bool initialize() = 0;
      double getControlSampleRate();
      int getLidarDataLength();
      int getIRDataLength();
      int getObsDataLength();
      std::vector<std::vector<double> > getLidarData();
      std::vector<std::vector<double> > getIRData();
      std::vector<double> getImuLTransAcc();
      double getImuLDOrientation();
      double getImuLOrientation();
      std::vector<double> getImuRTransAcc();
      double getImuRDOrientation();
      double getImuROrientation();
      std::vector<double> getEncPose();
      std::vector<double> getMotorCurrent();
      std::vector<double> getCalVelocity();
      void setEstPose(std::vector<double> const&);
      void setEstVelocity(std::vector<double> const&);
      void setEstAcceleration(std::vector<double> const&);
      void setEstGlobalOffset(std::vector<double> const&);
      void setObstacleData(std::vector<double> const&);      // not clear yet how to represent obstacles

- PathGeneratorInterface: needs to be inherited. Provides following methods for its children:
      virtual bool pathUpdate() = 0;
      virtual bool initialize() = 0;
      int _path_length;
      int getPathLength();
      double getControlSampleRate();
      double getPathUpdSampleRate();
      int getObsDataLength();
      std::vector<double> getKinLimitations();
      std::vector<double> getEstPose();
      std::vector<double> getTargetPose();
      std::vector<double> getObstacleData();
      void setRefPosePath(std::vector<double> const&, std::vector<double> const&, std::vector<double> const&);
      void setRefFfwPath(std::vector<double> const&, std::vector<double> const&, std::vector<double> const&);

- Reference: gets paths of PathGenerator. It samples the path, while in the mean time it receives a new path of PathGenerator. If current path is finished, it continues with next path. If there is no next path, it stays at last sample and shows a Warning to the rtt log

- VelocityCommandInterface: needs to be inherited. Provides following methods for its children:
      void setCmdVelocity(std::vector<double> const&);

Note: dummy implementation for Controller, Estimator, PathGenerator, VelocityCommander is made.
Alse DistributedControllerInterface, DistributedEstimatorInterface, DistributedPathGeneratorInterface and DistributedReference is written (but not tested...)

- Coordinator: implements the state machine (see further)

Interfacing with io's
---------------------

Following ports should be provided:
  cal_lidar_distances_port
  cal_lidar_angles_port
  cal_ir_distances_port
  cal_ir_angles_port
  cal_imul_transacc_port
  cal_imul_dorientation_port
  cal_imul_orientation_port
  cal_imur_transacc_port
  cal_imur_dorientation_port
  cal_imur_orientation_port
  cal_enc_pose_port
  cal_motor_current_port
  cal_velocity_port
  cmd_velocity_port
Following properties should be available:
  lidar_data_length
  ir_data_length
  obs_data_length

Deploying
---------
This is done by 'deploy.lua'script, called by 'run.ops'.
deploy.lua reads system-config.cpf and add properties: sample rates, type of estimator/controller/..., index of agent (every component is named as 'componentname+index', index of neighbours, ...)
and it starts its state machine with 3 major states (initial, failure(send event on failure port, cleanup and unload components), deploy, deployed)
deploy has a child state machine:
- load_components: imports packages/load components/make the necessary ones server
- configure_components: for all comp except coordinator and reporter: load properties via marshalling and call configure()
- connect_components
- connect_distr_components
- set_activities: defines the different threads with its priority/sample rate/master-slave dependency
- load_app_coordination: loads the coordinator .lua file, configures the coordinator, connects the failure port of coordinator to event port of deployer and visa versa, load app.ops (easy definition of operations), starts the coordinator
- prepare_reporter: load properties of reporter, add the reported components as peer and 'reportPort' the ports to connect per component

Coordinator
-----------
Run state machine, with major states:
- idle
- updpathfollowing
- fixedpathfollowing
- velocitycmdintern
- velocitycmdextern
- failure
switching between them is done by calling an operation

eg. updpathfollowing consists of child state machine:
- idle
- init: starts io's
- run: starts pathgenerator, reporter, controller/estimator/reference
      is evaluated periodically: updates reference/estimator/controller, checks for runtime errors in these components, and keeps track of period duration and jitter (is placed on a port)
- stop: stops pathgenerator, reference, estimator, controller, reporter
- reset: stops sensors

from stop state, you can go to start by e_restart or to reset, by e_reset, reset goes automatically to idle


EMPEROR
---------------------------------------------------------------------

Components
----------
- VelocityCommandInterface: needs to be inherited. Provides following methods for its children:
      void setCmdVelocity(std::vector<double> const&);

- Emperor (see later)

Deploying
---------
This is done by 'deploy.lua'script, called by 'run.ops'.
deploy.lua reads emperor-config.cpf and add properties: peers (index numbers of peers), velocitycmd_type, velcmd_sample_rate
and it loads its state machine:
deploy exists of:
- initial
- load_components: load internal components and their packages
- load_peers: load peer components over corba
- configure_components: loads properties and configures interal components
- connect_components
- set_activities: defines the different threads with its priority/sample rate/master-slave dependency
- load_app_coordination: loads the emperor .lua file, configures the emperor, connects the failure port of emperor to event port of deployer and visa versa, connects the emperor event ports to the coordinator event ports, connects the failure ports of each coordinator to the emperor event port and visa versa, load app.ops (easy definition of operations), starts the emperor
- prepare_reporter

Emperor
-------
Run state machine, with major states:
- idle
- updpathfollowing
- fixedpathfollowing
- velocitycmdintern
- velocitycmdextern
- failure
switching between them is done by calling an operation

eg. updpathfollowing consists of child state machine:
- idle
- init:
- run:
- stop:
- reset:
from stop state, you can go to start by e_restart or to reset, by e_reset, reset goes automatically to idle

nothin really implemented in those states, except snashot taking for reporter. Main goal is to keep track of states of agents



